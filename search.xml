<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>取模意义的快速幂黑科技：龟速乘</title>
      <link href="2020/11/22/ksm-slowpow/"/>
      <url>2020/11/22/ksm-slowpow/</url>
      
        <content type="html"><![CDATA[<p><strong>一般的快速幂：</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a,ll n,ll m)</span></span>{</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n){</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=ans*a%m;</span><br><span class="line">a=a*a%m;</span><br><span class="line">n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样会存在一个问题，当求$a^b\pmod{m}，$且$a&gt;10^9$时，会存在爆$long\ long$的问题，这时候我们需要对乘法取模进行改正，于是便有了龟速乘。</p><hr><p><strong>龟速乘：</strong></p><p>为什么要叫龟速乘呢，因为这个乘法运算比计算机底层的乘法速度要慢。<br>先看代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qmul</span><span class="params">(ll x,ll y,ll m)</span></span>{<span class="comment">//龟速乘 </span></span><br><span class="line">ll s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(y){</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) s=(s+x)%m;</span><br><span class="line">x=(x+x)%m;</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>形式与快速幂非常相似，只不过里面的乘法变成加法了，<br>比如$2\times 5= 2+2\times 4=2+4\times 2=2+8=10$。</p><p>时间复杂度：$O(logy)$</p><p>快速幂和龟速乘搭配一起就可以欢乐地进行模意义下的快速幂了。</p><p>复杂度：$O(logn\times log(a))$</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qmul</span><span class="params">(ll x,ll y,ll m)</span></span>{<span class="comment">//龟速乘 </span></span><br><span class="line">ll s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(y){</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) s=(s+x)%m;</span><br><span class="line">x=(x+x)%m;</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"><span class="comment">///////////////</span></span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a,ll n,ll m)</span></span>{</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n){</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=qmul(ans,a,m);</span><br><span class="line">a=qmul(a,a,m);</span><br><span class="line">n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="例题：-U55950-【模板】扩展欧拉定理"><a href="#例题：-U55950-【模板】扩展欧拉定理" class="headerlink" title="例题： U55950 【模板】扩展欧拉定理"></a>例题： U55950 【模板】扩展欧拉定理</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>,M=<span class="number">2e4</span>+<span class="number">5</span>,inf=<span class="number">0x3f3f3f3f</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">bool</span> f;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ll &amp;s)</span></span>{</span><br><span class="line"><span class="keyword">int</span> w=<span class="number">1</span>;<span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span>(c=getchar(),!<span class="built_in">isdigit</span>(c)){</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+(c&amp;<span class="number">15</span>),c=getchar();</span><br><span class="line">s*=w;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">readm</span><span class="params">(ll m)</span></span>{</span><br><span class="line">ll s=<span class="number">0</span>;<span class="keyword">char</span> c;<span class="keyword">while</span>(c=getchar(),!<span class="built_in">isdigit</span>(c)) ;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)){</span><br><span class="line">s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+(c&amp;<span class="number">15</span>);</span><br><span class="line"><span class="keyword">if</span>(s&gt;=m){</span><br><span class="line">s%=m;</span><br><span class="line">f=<span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line">c=getchar();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll n)</span></span>{</span><br><span class="line">ll s=n;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>){</span><br><span class="line">s-=s/i;</span><br><span class="line"><span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>) s-=s/n;<span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"><span class="function">ll <span class="title">qmul</span><span class="params">(ll x,ll y,ll m)</span></span>{<span class="comment">//龟速乘 </span></span><br><span class="line">ll s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(y){</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) s=(s+x)%m;</span><br><span class="line">x=(x+x)%m;</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line">ll a,m,b;</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a,ll n,ll m)</span></span>{</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n){</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=qmul(ans,a,m);</span><br><span class="line">a=qmul(a,a,m);</span><br><span class="line">n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">read(a),read(m);ll phim=phi(m);b=readm(phim);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ksm(a,b+(f?phim:<span class="number">0</span>),m));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tarjan的学习</title>
      <link href="2020/11/22/tarjan-study/"/>
      <url>2020/11/22/tarjan-study/</url>
      
        <content type="html"><![CDATA[<p>$Tarjan$是图论中求解关于图的连通性的相关问题的算法，$Tarjan$基于深搜$dfs$实现。</p><p>利用两个关键数组：$dfn[],low[]$。</p><p>$dfn[i]:$结点$i$的时间戳。</p><p>$low[i]:$结点$i$所能遍历的所有结点的最小$dfn$，可以类比并查集的$fa[i]$理解。</p><p>$id:$当前时间。</p><p>每次我们从一个结点$u$开始搜索，我们结点$u$能遍历到的所有结点组成的树成为结点$u$的搜索树，同时我们利用栈来保存处于同一个强连通分量的结点。</p><hr><p>算法的流程：</p><p>1.每次搜索到一个结点$u$，先初始化$dfn[u]=low[u]=++id$，然后结点$u$入栈。</p><p>2.然后依次遍历结点$u$的子树$v$，如果该点没有搜索过即$(!dfn[v])$就$dfs(v)$，然后更新$low[u]=min(low[u],low[v])$。</p><p>3.如果结点$v$搜索过且在栈中，说明该节点$v$可能是潜在的连通块的根，更新$low[u]=min(low[u],dfn[v])$，这里使用$dfn[v]$，因为$v$有可能属于别的连通块了。</p><p>4.搜索完$u$的所有能遍历的结点后，判断$dfn[u]=low[u]$，如果相等说明$u$是强连通分量的一个根，此时属于这个强连通分量的所有结点的$low[v]=low[u]$，然后回溯栈中所有节点染色为同一个连通块，同时可以统计该连通块的个数。</p><p>时间复杂度：$O(E+V)$</p><hr><p>$Tarjan$能解决的一些问题：</p><p>1.判断图是否连通。<br>2.判断图的连通分量个数。<br>3.判断每个连通分量的结点数。<br>4.缩点，将<strong>有向有环图</strong>(无向有环图的一条边可等价为两个有向边)转换为<strong>有向无环图$(DAG)$</strong><br>5.找到所有缩点，缩边。<br>6.求删去一个结点后图的连通分量个数，即判断每个点的缩边个数。<br>7.缩点后建立$DAG$，实现拓扑排序，树形$dp$，点权和状态转移等操作。<br>8.求缩点后新图的点出度，入度情况。<br>$\dots\dots$<br>模板：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,dfn[N],low[N],id,vis[N],ans,col[N],num[N],sum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;e[N];  <span class="comment">//dfs[i]记录结点i遍历顺序,low[i]记录结点i及其子结点最小遍历顺序,vis[i]标记是否在栈中。 </span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;<span class="comment">//col[i]记录结点i属于那个连通块(本题没用),num[i]记录第i个连通块的结点数. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line"> dfn[u]=low[u]=++id;<span class="comment">//记录dfs顺序 </span></span><br><span class="line"> s.push(u);<span class="comment">//入栈 </span></span><br><span class="line"> vis[u]=<span class="number">1</span>;<span class="comment">//标记入栈. </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u]){</span><br><span class="line">  <span class="keyword">if</span>(!dfn[v]){</span><br><span class="line">    dfs(v); <span class="comment">//没有遍历的点进行遍历然后更新low </span></span><br><span class="line">    low[u]=min(low[u],low[v]);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(vis[v]) low[u]=min(low[u],dfn[v]);<span class="comment">//如果已经遍历过而且在栈中 则取low较小值(这里是潜在的连通块) </span></span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">if</span>(dfn[u]==low[u]){ <span class="comment">//该点是连通块的"根"  注意孤立点也是连通块. </span></span><br><span class="line"> vis[u]=<span class="number">0</span>;   <span class="comment">//回溯标记，并染色. </span></span><br><span class="line"> col[u]=++sum;</span><br><span class="line"> num[sum]++;</span><br><span class="line"> <span class="keyword">while</span>(s.top()!=u){ <span class="comment">//依次出栈. </span></span><br><span class="line"> col[s.top()]=sum;</span><br><span class="line">  vis[s.top()]=<span class="number">0</span>;</span><br><span class="line">  s.pop();</span><br><span class="line">  num[sum]++;</span><br><span class="line"> }</span><br><span class="line"> s.pop();</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>求割点，只需要判断$low[v]\ge dfn[u]$即可，因为如果满足的话，显然去掉$u$后就不能访问$v$子树了，所以$u$就是割点，$edge(u,v)$就是割边。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>{</span><br><span class="line">dfn[u]=low[u]=++id;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i;i=e[i].nt){</span><br><span class="line"><span class="keyword">int</span> v=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v]){</span><br><span class="line">dfs(v,u);</span><br><span class="line">low[u]=min(low[u],low[v]);</span><br><span class="line"><span class="keyword">if</span>(low[v]&gt;=dfn[u]) cut[u]++; <span class="comment">//关键</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(v!=fa) low[u]=min(low[u],dfn[v]);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="1-POJ-2117​"><a href="#1-POJ-2117​" class="headerlink" title="1.POJ 2117​"></a>1.POJ 2117​</h2><p>无向图删去后一个点后的最多连通分量数。<br>思路：以$i$为根依次进行搜索，记录该点的割边数$cut[i]$，如果$cut[i]=0$，说明它是孤立点，删去它后贡献减1，如果$cut[i]=1$且它只有一个儿子，删去它后，连通分量个数还是$1$，贡献也是$cut[i]-1$，若$cut[i]&gt;1$，且$i$为根，则新增的连通分量数$cut[i]-1$，因为不包括自身的连通分量。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>{</span><br><span class="line">dfn[u]=low[u]=++id;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i;i=e[i].nt){</span><br><span class="line"><span class="keyword">int</span> v=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v]){</span><br><span class="line">dfs(v,u);</span><br><span class="line">low[u]=min(low[u],low[v]);</span><br><span class="line"><span class="keyword">if</span>(low[v]&gt;=dfn[u]) cut[u]++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(v!=fa) low[u]=min(low[u],dfn[v]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++){</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);add(u,v);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>,mx=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!dfn[i]){</span><br><span class="line">dfs(i,<span class="number">-1</span>),tot++,cut[i]--;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,tot+cut[i]);</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2020ICPC网络赛-D-Router-Mesh"><a href="#2-2020ICPC网络赛-D-Router-Mesh" class="headerlink" title="2. 2020ICPC网络赛 D.Router Mesh"></a>2. 2020ICPC网络赛 D.Router Mesh</h2><p>题意：给定无向图，求删去每个结点后的连通分量数。<br>思路：利用上题的方法求出$cut[i]$，然后用原连通分量数$tot+cut[i]$即可。</p><h2 id="3-POJ-2553"><a href="#3-POJ-2553" class="headerlink" title="3.POJ 2553"></a>3.POJ 2553</h2><p>题意：求有向图缩点后连通分量没有出度的点。</p><p>思路：$tarjan$缩点给连通块染色，然后判断每条边$edge(u,v)$的$bl[u]$是否等于$bl[v]$，如果不相等说明结点$bl[u]$这个连通分量有出度，最后输出$bl[u]=0$的点即可。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">dfn[u]=low[u]=++id;</span><br><span class="line">vis[u]=<span class="number">1</span>,s.push(u);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e[u].size();i++){</span><br><span class="line"><span class="keyword">int</span> v=e[u][i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[v]){</span><br><span class="line">dfs(v);</span><br><span class="line">low[u]=min(low[u],low[v]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v]) low[u]=min(low[u],dfn[v]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u]){</span><br><span class="line">bl[u]=++tot,vis[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(s.top()!=u){</span><br><span class="line">vis[s.top()]=<span class="number">0</span>,bl[s.top()]=tot,s.pop();</span><br><span class="line">}</span><br><span class="line">s.pop();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;e[u].size();j++){</span><br><span class="line"><span class="keyword">if</span>(bl[u]!=bl[e[u][j]]){</span><br><span class="line">chu[bl[u]]=<span class="literal">true</span>;<span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">if</span>(!chu[bl[i]]) <span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br></pre></td></tr></tbody></table></figure><h2 id="4-10103-「一本通-3-6-练习-4」电力"><a href="#4-10103-「一本通-3-6-练习-4」电力" class="headerlink" title="4.10103. 「一本通 3.6 练习 4」电力"></a>4.10103. 「一本通 3.6 练习 4」电力</h2><p>跟$POJ2117$ 一样的，不写了。</p><h2 id="5-P3388"><a href="#5-P3388" class="headerlink" title="5.P3388"></a>5.P3388</h2><p>求无向图的割点。<br>注意：结点为根且儿子只有一个不是割点。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>{</span><br><span class="line">dfn[u]=low[u]=++id;</span><br><span class="line"><span class="comment">//s.push(u);</span></span><br><span class="line"><span class="keyword">int</span> son=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i;i=e[i].nt){</span><br><span class="line"><span class="keyword">int</span> v=e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v]){</span><br><span class="line">son++;</span><br><span class="line">dfs(v,u);</span><br><span class="line">low[u]=min(low[u],low[v]);</span><br><span class="line"><span class="keyword">if</span>(low[v]&gt;=dfn[u]) cut[u]=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(v!=fa) low[u]=min(low[u],dfn[v]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(fa&lt;<span class="number">0</span>&amp;&amp;son==<span class="number">1</span>) cut[u]=<span class="number">0</span>;<span class="comment">//结点u为树根 且只有一个儿子 </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="6-P2863-USACO06JAN-The-Cow-Prom-S"><a href="#6-P2863-USACO06JAN-The-Cow-Prom-S" class="headerlink" title="6.P2863 [USACO06JAN]The Cow Prom S"></a>6.P2863 [USACO06JAN]The Cow Prom S</h2><p>直接一遍搜然后统计$cnt$即可。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>{</span><br><span class="line">dfn[u]=low[u]=++id;</span><br><span class="line">vis[u]=<span class="number">1</span>,s.push(u);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v:e[u]){</span><br><span class="line"><span class="keyword">if</span>(!dfn[v]){</span><br><span class="line">dfs(v,u);</span><br><span class="line">low[u]=min(low[u],low[v]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v]) low[u]=min(low[u],dfn[v]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u]){<span class="comment">//统计cnt&gt;1 即为结点个数大于1的强连通分量 </span></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>; </span><br><span class="line">vis[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(s.top()!=u){</span><br><span class="line">cnt++,vis[s.top()]=<span class="number">0</span>,s.pop();</span><br><span class="line">}</span><br><span class="line">s.pop();</span><br><span class="line"><span class="keyword">if</span>(cnt&gt;<span class="number">1</span>) ans++;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="7-P3387-【模板】缩点"><a href="#7-P3387-【模板】缩点" class="headerlink" title="7.P3387 【模板】缩点"></a>7.P3387 【模板】缩点</h2><p>思路：缩点转$DAG$图跑$dp$或者拓扑即可。</p><p>$dp$写法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>,M=<span class="number">2e4</span>+<span class="number">5</span>,inf=<span class="number">0x3f3f3f3f</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">int</span> n,m,id,cnt;</span><br><span class="line"><span class="keyword">int</span> a[N],dfn[N],low[N],vis[N],bl[N],b[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;e[N],ne[N];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>{</span><br><span class="line">dfn[u]=low[u]=++id;</span><br><span class="line">vis[u]=<span class="number">1</span>,s.push(u);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v:e[u]){</span><br><span class="line"><span class="keyword">if</span>(!dfn[v]){</span><br><span class="line">dfs(v,u);</span><br><span class="line">low[u]=min(low[u],low[v]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v]) low[u]=min(low[u],dfn[v]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u]){</span><br><span class="line">bl[u]=++cnt,b[cnt]+=a[u]; </span><br><span class="line">vis[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(s.top()!=u){</span><br><span class="line">vis[s.top()]=<span class="number">0</span>,bl[s.top()]=cnt,b[cnt]+=a[s.top()],s.pop();</span><br><span class="line">}</span><br><span class="line">s.pop();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(f[u]) <span class="keyword">return</span>;</span><br><span class="line">f[u]+=b[u];<span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v:ne[u]){</span><br><span class="line"><span class="keyword">if</span>(!f[v]) fun(v);</span><br><span class="line">mx=max(mx,f[v]);</span><br><span class="line">}</span><br><span class="line">f[u]+=mx;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++){</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v),e[u].pb(v);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!dfn[i]) dfs(i,<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v:e[u]){</span><br><span class="line"><span class="keyword">if</span>(bl[u]!=bl[v]){</span><br><span class="line">ne[bl[u]].pb(bl[v]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!f[i]){</span><br><span class="line">fun(i);</span><br><span class="line">ans=max(ans,f[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>拓扑写法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topo</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(!in[i]) q.push(i),f[i]=b[i];</span><br><span class="line"><span class="keyword">while</span>(!q.empty()){</span><br><span class="line"><span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v:ne[u]){</span><br><span class="line">in[v]--;</span><br><span class="line">f[v]=max(f[v],f[u]+b[v]);</span><br><span class="line"><span class="keyword">if</span>(!in[v]) q.push(v);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)  ans=max(ans,f[i]);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="8-P2341-HAOI2006-受欢迎的牛-G"><a href="#8-P2341-HAOI2006-受欢迎的牛-G" class="headerlink" title="8. P2341 HAOI2006 受欢迎的牛 G"></a>8. P2341 HAOI2006 受欢迎的牛 G</h2><p>思路：有向图先缩点，然后判断每个点出度是否为0，如果出现一个以上的点出度为0，说明不可能有能被所有其他点遍历的点，否则那个一点肯定是能被其他点遍历到的点，因为其他点一直有出度可以出去，直到找到那个点就停止。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v:e[u]){</span><br><span class="line"><span class="keyword">if</span>(bl[u]!=bl[v]){</span><br><span class="line">out[bl[u]]++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++){</span><br><span class="line"><span class="keyword">if</span>(!f&amp;&amp;!out[i]){</span><br><span class="line">f=i;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!out[i]){</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>),<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="9-P2746-USACO5-3-校园网Network-of-Schools"><a href="#9-P2746-USACO5-3-校园网Network-of-Schools" class="headerlink" title="9.P2746 [USACO5.3]校园网Network of Schools"></a>9.P2746 [USACO5.3]校园网Network of Schools</h2><p>思路：任务$A$答案就是入度为$0$的点，因为这些点不能由其他点分发过来，<br>任务$B$就是取入度为0点的个数和出度为0的点个数的最大值，但是需要注意的是如果图本身是一个环的话就不需要再扩展了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v:e[u]){</span><br><span class="line"><span class="keyword">if</span>(bl[u]!=bl[v]){</span><br><span class="line">in[bl[v]]++,out[bl[u]]++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++){</span><br><span class="line"><span class="keyword">if</span>(!in[i]) tot++;</span><br><span class="line"><span class="keyword">if</span>(!out[i]) tmp++;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tot);</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(tot,tmp));</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的博客要搬家了</title>
      <link href="2020/11/22/moving-home/"/>
      <url>2020/11/22/moving-home/</url>
      
        <content type="html"><![CDATA[<h1 id="我的博客准备搬家了"><a href="#我的博客准备搬家了" class="headerlink" title="我的博客准备搬家了"></a>我的博客准备搬家了</h1><p><strong>hexo</strong>真是太好玩了，继续$Working$中。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">include&lt;bits/stdc++.h&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
